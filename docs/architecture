## Parlay Gorilla — System Architecture Overview (Non‑Code)

**Audience:** internal engineering / operations  
**Purpose:** explain how Parlay Gorilla’s web app components work together, including optional verification records, without exposing user-facing terminology that would confuse customers.

---

## Product context (high level)

Parlay Gorilla is a standard AI SaaS web application for sports parlay analysis and decision support. It provides:

- AI-generated parlays and explanations
- Custom parlay builder + analysis
- Saved parlays + analytics dashboard
- Optional verification records (user-initiated, hash-only, time-stamped)

---

## Runtime services

- **Frontend (Next.js / TypeScript)**: UI, session handling, dashboards, saved parlays, verification record UX.
- **Backend API (FastAPI / Python)**: authentication, games/odds APIs, custom parlay analysis, persistence, and verification job production.
- **Verification Worker (Node / TypeScript)**: background consumer that creates immutable verification records and updates the database with confirmation details.
- **PostgreSQL**: durable storage (users, saved parlays, verification records, analytics).
- **Redis**: cache + background job queue (verification jobs; also used for coordination across instances).

---

## Verification records (optional)

### Scope and policy

- Verification records are available only for **Custom** saved parlays.
- They are created only when a user explicitly opts in (e.g., “Save + Verify”).
- The system enforces plan limits:
  - Premium includes a monthly verification cap.
  - After the included cap is exhausted, Premium users can continue by spending credits (per verification).

### Privacy & data minimization

Verification records are **hash-only**:

- No emails, usernames, display names, or other PII are written into the verification payload.
- The system uses a non-PII, stable account identifier (`account_number`) for deterministic payload construction.
- The canonical payload is hashed (SHA-256) before recording.

### Deterministic hashing guarantees

To avoid hash churn (e.g., selecting the same legs in a different order), the backend computes a deterministic hash from a canonical payload:

- stable schema + app version
- saved parlay id
- non-PII account number
- created-at timestamp (UTC)
- deterministically ordered legs snapshot (stable sort key)

### Producer/consumer separation (security boundary)

The verification system separates responsibilities:

- **API tier** validates user intent and queues a verification job. It does not hold signing keys.
- **Worker tier** holds the signing key and performs the immutable record creation.

This keeps critical secrets out of the API blast radius and matches least-privilege expectations for production.

---

## Operational notes

- **Idempotency**: retries should not double-charge credits or consume quota more than once per saved parlay verification attempt.
- **Retries/backoff**: worker retries transient failures with bounded attempts; terminal failures are recorded on the verification record for user-friendly messaging.
- **Observability**: structured logs for enqueue, dequeue, record creation success/failure, and DB update outcomes.


