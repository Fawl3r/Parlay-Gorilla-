# Authentication Policy

**Policy ID:** AUTH-001  
**Version:** 1.0  
**Effective Date:** 2025-01-XX  
**Review Frequency:** Quarterly  
**Owner:** Development Team

---

## 1. Purpose

This policy defines authentication requirements for Parlay Gorilla, including password policies, JWT token management, and multi-factor authentication (MFA) requirements.

---

## 2. Scope

This policy applies to:
- **Application Authentication:** User login, admin login, API authentication
- **Infrastructure Authentication:** Render dashboard, GitHub, third-party service accounts
- **Token Management:** JWT access tokens, refresh tokens (when implemented)

---

## 3. Authentication Methods

### 3.1 Application Authentication

**Method:** Email + Password → JWT Token

**Flow:**
1. User submits email and password to `/api/auth/login`
2. Backend validates credentials against database
3. Backend generates JWT access token
4. Token returned to frontend (stored in localStorage and HttpOnly cookie)
5. Token included in subsequent API requests via `Authorization: Bearer <token>` header

**Implementation:**
- **Backend:** `backend/app/api/routes/auth.py` → `login()` endpoint
- **Frontend:** `frontend/lib/auth-context.tsx` → `signIn()` function
- **Token Generation:** `backend/app/services/auth_service.py` → `create_access_token()`

### 3.2 Admin Authentication

**Method:** Email + Password → JWT Token (same as user, but role check required)

**Flow:**
1. Admin submits email and password to `/api/admin/auth/login`
2. Backend validates credentials
3. Backend verifies `user.role == "admin"`
4. Backend generates JWT token with admin role
5. Token used for admin endpoint access

**Implementation:**
- **Backend:** `backend/app/api/routes/admin/auth.py` → `admin_login()` endpoint

---

## 4. Password Requirements

### 4.1 Password Policy

**Current Implementation:**
- **Minimum Length:** Not enforced (should be 8+ characters - see Remediation Backlog)
- **Complexity:** Not enforced (should require mix of characters - see Remediation Backlog)
- **Expiration:** Not enforced (passwords do not expire)
- **History:** Not enforced (users can reuse previous passwords)

### 4.2 Password Hashing

**Algorithm:** PBKDF2-SHA256 (new passwords), bcrypt (legacy support)

**Implementation:**
- **Location:** `backend/app/services/auth/password_hasher.py`
- **New Passwords:** Hashed with `pbkdf2_sha256.hash(password)`
- **Legacy Support:** Verifies bcrypt and bcrypt-sha256 hashes, upgrades to PBKDF2-SHA256 on next login
- **72-Byte Limit:** Handled automatically (bcrypt limitation)

**Code Reference:**
```python
# Password hashing
_password_hasher = PasswordHasher()
def get_password_hash(password: str) -> str:
    return _password_hasher.hash_password(password)
```

### 4.3 Password Reset

**Flow:**
1. User requests reset via `/api/auth/forgot-password`
2. Backend generates password reset token (stored in `verification_tokens` table)
3. Email sent with reset link (if Resend API configured)
4. User submits new password via `/api/auth/reset-password` with token
5. Token validated, password updated, token invalidated

**Implementation:**
- **Backend:** `backend/app/api/routes/auth.py` → `forgot_password()` and `reset_password()` endpoints
- **Token Storage:** `backend/app/models/verification_token.py`
- **Token Expiration:** 24 hours (configurable)

---

## 5. JWT Token Management

### 5.1 Token Generation

**Algorithm:** HS256 (HMAC-SHA256)

**Secret:** Stored in `JWT_SECRET` environment variable (auto-generated by Render in production)

**Payload:**
```json
{
  "sub": "<user_id>",
  "email": "<user_email>",
  "exp": <expiration_timestamp>
}
```

**Expiration:** 24 hours (configurable via `JWT_EXPIRATION_HOURS`)

**Implementation:**
- **Location:** `backend/app/services/auth_service.py` → `create_access_token()`
- **Code:**
```python
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_HOURS = 24

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    expire = datetime.now(timezone.utc) + timedelta(hours=ACCESS_TOKEN_EXPIRE_HOURS)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, settings.jwt_secret, algorithm=ALGORITHM)
```

### 5.2 Token Validation

**Process:**
1. Extract token from `Authorization: Bearer <token>` header or `access_token` cookie
2. Decode and verify signature using `JWT_SECRET`
3. Verify expiration (`exp` claim)
4. Extract `sub` (user_id) from payload
5. Fetch user from database
6. Return user object for dependency injection

**Implementation:**
- **Location:** `backend/app/core/dependencies.py` → `get_current_user()`
- **Code:**
```python
def decode_access_token(token: str) -> Optional[dict]:
    try:
        payload = jwt.decode(token, settings.jwt_secret, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None
```

### 5.3 Token Storage

**Frontend Storage:**
- **localStorage:** Token stored as `auth_token` (XSS risk - see Remediation Backlog)
- **HttpOnly Cookie:** Token also set as HttpOnly cookie (hybrid mode)
- **Implementation:** `frontend/lib/auth-context.tsx` and `backend/app/services/auth/cookie_manager.py`

**Security Considerations:**
- localStorage is accessible to JavaScript (XSS risk)
- HttpOnly cookies are not accessible to JavaScript (more secure)
- Current implementation uses both (hybrid mode)

### 5.4 Token Refresh

**Current Status:** Not implemented (see Remediation Backlog)

**Proposed Implementation:**
- Short-lived access tokens (15 minutes)
- Long-lived refresh tokens (7 days)
- Refresh endpoint: `/api/auth/refresh`
- Refresh tokens stored in database with revocation capability

---

## 6. Rate Limiting

### 6.1 Authentication Endpoints

**Login:** 10 attempts per minute per IP
**Register:** 5 registrations per minute per IP
**Forgot Password:** 5 requests per hour per IP
**Reset Password:** 10 attempts per hour per IP

**Implementation:**
- **Location:** `backend/app/api/routes/auth.py`
- **Decorator:** `@rate_limit("10/minute")`
- **Library:** `slowapi` (FastAPI rate limiting)

**Code Reference:**
```python
@router.post("/login", response_model=TokenResponse)
@rate_limit("10/minute")
async def login(...):
    # Login logic
```

---

## 7. Multi-Factor Authentication (MFA)

### 7.1 Current Status

**Application MFA:** Not implemented (see Remediation Backlog)

**Infrastructure MFA:**
- **Render Dashboard:** Should be enabled (see Remediation Backlog)
- **GitHub:** Should be enabled (see Remediation Backlog)

### 7.2 MFA Requirements

**Recommended Implementation:**
- TOTP (Time-based One-Time Password) via authenticator apps
- SMS-based MFA (optional, less secure)
- Backup codes for account recovery

**Enforcement:**
- Admin accounts: MFA required
- User accounts: MFA optional (recommended)

---

## 8. Session Management

### 8.1 Session Duration

**Access Token:** 24 hours
**Refresh Token:** Not implemented (see Remediation Backlog)

### 8.2 Session Termination

**Logout:**
- Frontend: Clears localStorage token
- Backend: `/api/auth/logout` endpoint (if implemented)
- **Current Status:** Token remains valid until expiration (no server-side revocation)

**Token Revocation:**
- **Current Status:** Not implemented (tokens valid until expiration)
- **Recommended:** Implement token blacklist or refresh token revocation

---

## 9. Failed Authentication Handling

### 9.1 Failed Login Attempts

**Rate Limiting:** Prevents brute force attacks (10 attempts/minute)

**Error Messages:**
- Generic error: "Incorrect email or password" (does not reveal if email exists)
- Prevents user enumeration attacks

**Implementation:**
```python
if not user:
    raise HTTPException(status_code=401, detail="Incorrect email or password")
```

### 9.2 Account Lockout

**Current Status:** Not implemented (rate limiting only)

**Recommended:** Implement account lockout after N failed attempts (see Remediation Backlog)

---

## 10. Compliance

This policy supports SOC 2 Type I readiness under **Security Trust Service Criteria CC6.2** (System access authentication).

---

## 11. Policy Review

This policy is reviewed quarterly or when:
- Authentication mechanisms change
- Security incidents occur
- New authentication methods are added

---

**Approved By:** [To be filled]  
**Last Review Date:** [To be filled]  
**Next Review Date:** [To be filled]
